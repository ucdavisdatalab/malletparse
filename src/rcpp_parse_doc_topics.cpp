#include <Rcpp.h>
#include <cstring> //strtok and igzstream
#include <cmath> //ceil and floor
#include <iomanip>
#include "gzstream.h" // add -lz to compile

// should be able to handle gz doc topics and mallet doc topics form

void insertsorted (std::vector<int> &inds, std::vector<double> &values, double value, int line_index, int topn);
std::string get_top_topics(std::vector<int> inds, std::vector<double> values, double quantile);
std::vector<std::string> strsplit (std::string input, char delim);
double quantile (std::vector<double> values, double q);
Rcpp::List rcpp_parse_doc_topics(std::string fpath, int topn, std::string, double q, const Rcpp::NumericVector doc_lens); 
Rcpp::List rcpp_parse_doc_topics_gz(std::string fpath, int topn, std::string ttfile, double q, const Rcpp::NumericVector doc_lens);
Rcpp::List rcpp_parse_doc_topics_mallet(std::string fpath, int topn, std::string ttfile, double q, const Rcpp::NumericVector doc_lens);

//' Rcpp Parse Document Topics File either from --output-doc-topics or from the parsed state file.
//'
//' Allows for parsing information from the document terms matrix without loading the full thing into memory.
//' Can accept as input either the doc topics file output from MALLET, or the gzipped doc topics generated by
//' this package's rcpp_parse_topic_state function.
//' From the document topic matrix file this function extracts the top documents for each topic.
//' In addition, this function can optionally extract the top topics for each document, and if given as input
//' a vector containing the lengths of each document, can extract the topic frequency for each topic.
//'
//' @param fpath A string specifying the path to either the --output-doc-topics file or a gzipped doc topics file generated by this package.
//' @param topn A Number specifying the number of documents to save for each topic.
//' @param ttfile **optional** A string specifying the path to an output gzipped file in which to save the top topics for each document.
//' @param q **optional** A real number (defaults to 0.70) specifying the percentile of top topics to save for each document.
//' @param doc_lens **optional** An integer vector containing the number of tokens in each document, if provided, the topic frequencies are calculated.
//' @return A list with these components:
//' \describe{
//'   \item{top_docs_inds}{Numeric Matrix (K X topn) each cell has the index of the document starting at 0}
//'   \item{top_docs_values}{Numeric Matrix (K X topn) each cell has the doc topic score for the document, corresponds wiht top_docs_inds}
//'   \item{topic_frequencies}{A numeric vector of length(K) where each value is the topic proprotion, empty if doc_lens not provided}
//' }
//' @export
// [[Rcpp::export]]
Rcpp::List rcpp_parse_doc_topics(std::string fpath, int topn, std::string ttfile = "", double q= 0.70, const Rcpp::NumericVector doc_lens = Rcpp::NumericVector::create())
{
    if(fpath.substr( fpath.length() - 2 ) == "gz")
	return(rcpp_parse_doc_topics_gz(fpath, topn, ttfile, q, doc_lens));
    else
	return(rcpp_parse_doc_topics_mallet(fpath, topn, ttfile, q, doc_lens));
}

Rcpp::List rcpp_parse_doc_topics_gz(std::string fpath, int topn, std::string ttfile, double q, const Rcpp::NumericVector doc_lens)
{
    ogzstream outfile;
    if (ttfile != "")
    {
	outfile.open(ttfile.c_str());
	std::string info = "#Note topics start at 0\n";
	info = info + "#if NTOPICS < 20 then all are printed regardless of if they are larger than quartile\n";
	info = info + "#quartile = " + std::to_string(q) + "\n";
	info = info + "#topic:count:normalized_value\ttopic:count:normalized_value\t...\n";
	outfile << info;
    }
    // NOTE THAT FOR SOME REASON IGZSTREAM DOESNT HAVE SEEK AND IF I PARSE THE FIRST LINE SEPARATELY THINGS GET WEIRD LATER!!
    // SO: NEED TO DO ALL IN ONE PASS
    // =================================================
    igzstream infile;
    infile.open(fpath.c_str());


    std::vector<std::string> res;
    int ntopics = 0;
    int line_index = 0;
    double sum = 0.0;
    std::string line = "";
    std::string result = "";
    char c;
    std::vector <std::vector<double> > topic_top_doc_values;
    std::vector <std::vector<int> > topic_top_doc_inds;
    std::vector <double> doc_top_topics_values;
    std::vector <int> doc_top_topics_inds;
    Rcpp::NumericVector topic_frequencies;
    std::vector <double> doctopics_vec;
    if (infile)
    {
	//read characters until first newline:
	while (infile.get(c)) 
	{
	    if (line_index % 100000 == 0 && line_index != 0)
		Rcpp::Rcout << std::setprecision(3) << (double)line_index / 1000000 << " million lines \n";

	    line = line + c;

	    // FOR THE FIRST LINE
	    if (c == '\n' && line_index == 0)
	    {
		res = strsplit(line, ' ');
		ntopics = res.size();
		for (int i = 0; i < ntopics; i++)
		    doctopics_vec.push_back(std::stof(res[i]));

                sum = 0;
                for (int i = 0; i < ntopics; i++)
            	    sum = sum + doctopics_vec[i];
                for (int i = 0; i < ntopics; i++)
            	    doctopics_vec[i] = doctopics_vec[i] / sum;

		for (int i = 0; i < ntopics; i++)
		{
		    std::vector <double> row_values(topn, 0.0);
		    std::vector <int> row_inds(topn, 0);
		    row_values[0] = doctopics_vec[i];
		    row_inds[0] = line_index;
		    topic_top_doc_values.push_back(row_values);
		    topic_top_doc_inds.push_back(row_inds);

                    if (ttfile != "")
		    {
		        doc_top_topics_inds.push_back(i);
		        doc_top_topics_values.push_back(doctopics_vec[i]);
		    }
                    if (doc_lens.size() != 0)
                        topic_frequencies.push_back(doctopics_vec[i] * doc_lens[line_index]);
		}

                if (ttfile != "")
                {
                    result = get_top_topics(doc_top_topics_inds, doc_top_topics_values, q); //make sure to append to file
                    outfile << result;
                    doc_top_topics_inds.clear();
                    doc_top_topics_values.clear();
                    result = "";
                }
		line = "";
		line_index++;
	    }


	    // FOR EACH OTHER LINE
	    else if (c == '\n')
	    {
		res = strsplit(line, ' ');
		for (int i = 0; i < ntopics; i++)
		    doctopics_vec[i] = std::stof(res[i]);

                sum = 0;
                for (int i = 0; i < ntopics; i++)
            	    sum = sum + doctopics_vec[i];
                for (int i = 0; i < ntopics; i++)
            	    doctopics_vec[i] = doctopics_vec[i] / sum;

                for (int i = 0; i < ntopics; i++)
                {
                    insertsorted(topic_top_doc_inds[i], topic_top_doc_values[i], doctopics_vec[i], line_index, topn);
                    if (doc_lens.size() != 0)
                        topic_frequencies[i] += (doctopics_vec[i] * doc_lens[line_index]);

                    if (ttfile != "")
                    {
                        doc_top_topics_inds.push_back(i);
                        doc_top_topics_values.push_back(doctopics_vec[i]);
                    }
                }

                if (ttfile != "")
                {
                    result = get_top_topics(doc_top_topics_inds, doc_top_topics_values, q); //make sure to append to file
                    outfile << result;
                    doc_top_topics_inds.clear();
                    doc_top_topics_values.clear();
                    result = "";
                }

		line = "";
		line_index++;
	    }
	}

    } // while infile is open
    else
	Rcpp::stop("file not found");

    infile.clear();
    infile.close();

    //normalize topic_frequencies
    sum = 0;
    for (int i =0; i < topic_frequencies.size(); i++)
	sum = sum + topic_frequencies[i];
    for (int i =0; i < topic_frequencies.size(); i++)
	topic_frequencies[i] = topic_frequencies[i] / sum;

    //convert vector of vectors to Rcpp Matrices
    Rcpp::NumericMatrix top_docs_inds(ntopics,topn);
    Rcpp::NumericMatrix top_docs_values(ntopics,topn);
    for (int i =0; i < ntopics; i++)
    {
	for(int j =0; j < topn; j++)
	{
	    top_docs_inds(i,j) = topic_top_doc_inds[i][j];
	    top_docs_values(i,j) = topic_top_doc_values[i][j];
	}
    }


    return Rcpp::List::create(
	    Rcpp::Named("top_docs_inds") = top_docs_inds,
	    Rcpp::Named("top_docs_values") = top_docs_values,
	    Rcpp::Named("topic_frequencies") = topic_frequencies);
}


Rcpp::List rcpp_parse_doc_topics_mallet(std::string fpath, int topn, std::string ttfile, double q, const Rcpp::NumericVector doc_lens)
{
    std::ifstream infile;
    infile.open(fpath);

    int ntopics = 0;
    std::string line;
    char delim[] = " \t"; //space and tab

    if (infile.is_open())
    {
	getline(infile, line);
	char *token = strtok (&line[0u], delim);
	{
	    while (token != NULL)
	    {
		ntopics++;
		token = strtok(NULL, delim);
	    }
	}
    }//
    ntopics = ntopics -2; //the first two columns are doc id and docname
    infile.clear();
    infile.close();

    /* =================================================
       ALLOCATE DATA STRUCTURES AND FILL WITH 0s      */
    std::vector <std::vector <int> > topic_top_doc_inds;
    std::vector <std::vector <double> > topic_top_doc_values;
    for (int i = 0; i < ntopics; i++)
    {
	std::vector <int> ri(topn, 0);
	std::vector <double> rv(topn, 0.0);
	topic_top_doc_inds.push_back(ri);
	topic_top_doc_values.push_back(rv);
    }
    Rcpp::NumericVector topic_frequencies(ntopics);

    std::vector <int> doc_top_topics_inds;
    std::vector <double> doc_top_topics_values;

    ogzstream outfile;
    if (ttfile != "")
    {
	outfile.open(ttfile.c_str());
	std::string info = "#Note topics start at 0\n";
	info = info + "#if NTOPICS < 20 then all are printed regardless of if they are larger than quartile\n";
	info = info + "#quartile = " + std::to_string(q) + "\n";
	info = info + "#topic:count:normalized_value\ttopic:count:normalized_value\t...\n";
	outfile << info;
    }
    std::string result = "";

    /* =================================================
       OPEN FILE AND ITERATE THROUGH LINES */
    infile.open(fpath);
    infile.seekg (0, std::ios::beg);
    int line_index = 0;  // which document
    double sum = 0.0;
    std::vector <std::string> elem;
    std::vector <double> doctopics_vec(ntopics, 0.0);


    if (infile.is_open())
    {
	while (getline(infile, line))
	{
	    if (line_index % 100000 == 0 && line_index != 0)
		Rcpp::Rcout << std::setprecision(3) << (double)line_index / 1000000 << " million lines \n";

	    elem = strsplit(line, '\t');
	    elem.erase (elem.begin(), elem.begin() + 2); // delete the first two values
	    for (int i = 0; i < ntopics; i++)
	    {
		doctopics_vec[i] = std::stof(elem[i]);
	    }

	    sum = 0.0;
            for (int i = 0; i < ntopics; i++)
	    {
                sum = sum + doctopics_vec[i];
	    }

            for (int i = 0; i < ntopics; i++)
                doctopics_vec[i] = doctopics_vec[i] / sum;

            for (int i = 0; i < ntopics; i++)
            {
                insertsorted(topic_top_doc_inds[i], topic_top_doc_values[i], doctopics_vec[i], line_index, topn);
                if (doc_lens.size() != 0)
                    topic_frequencies[i] += (doctopics_vec[i] * doc_lens[line_index]);

                if (ttfile != "")
                {
                    doc_top_topics_inds.push_back(i);
                    doc_top_topics_values.push_back(doctopics_vec[i]);
                }
            }

	    if (ttfile != "")
	    {
		result = get_top_topics(doc_top_topics_inds, doc_top_topics_values, q); //make sure to append to file
		outfile << result;
		doc_top_topics_inds.clear();
		doc_top_topics_values.clear();
		result = "";
	    }//if ttfile

	    line_index++;
	} //while line
	infile.close();
    } // while infile is open

    //normalize topic_frequencies
    sum = 0;
    for (int i = 0; i < topic_frequencies.size(); i++)
	sum = sum + topic_frequencies[i];
    for (int i = 0; i < topic_frequencies.size(); i++)
	topic_frequencies[i] = topic_frequencies[i] / sum;

    //convert vector of vectors to Rcpp Matrices
    Rcpp::NumericMatrix top_docs_inds(ntopics,topn);
    Rcpp::NumericMatrix top_docs_values(ntopics,topn);
    for (int i =0; i < ntopics; i++)
    {
	for(int j =0; j < topn; j++)
	{
	    top_docs_inds(i,j) = topic_top_doc_inds[i][j];
	    top_docs_values(i,j) = topic_top_doc_values[i][j];
	}
    }


    return Rcpp::List::create(
	    Rcpp::Named("top_docs_inds") = top_docs_inds,
	    Rcpp::Named("top_docs_values") = top_docs_values,
	    Rcpp::Named("topic_frequencies") = topic_frequencies);
}

void insertsorted (std::vector <int> &inds, std::vector<double> &values, double value, int line_index, int topn)
{
    bool a = false;
    int i = topn - 1;
    while (i > 0)
    {
	if (value > values[i-1])
	{
	    a = true;
	    values[i] = values[i-1];
	    inds[i] = inds[i-1];
	}
	else
	    break;
	i--;
    }

    if (a)
    {
	values[i] = value; 
	inds[i] = line_index; 
    }
    else if (value > values[i])
    {
	values[i] = value; 
	inds[i] = line_index; 
    }

    return;
}// insersorted

std::string get_top_topics (std::vector<int> inds, std::vector<double> values, double q)
{
    // sort values vector and inds vector based on indexes of values sort
    int i,j,n; 
    n = values.size();
    std::string result = "";
    double key = 0.0;

    std::vector<int> sorted_inds(n,0);
    std::vector<double> sorted_values(n,0.0);
    for  (i = 0; i < n; i++)
    {
	key = values[i];
	j = i - 1;
	while (j >= 0 && key > sorted_values[j])
	{
	    sorted_values[j + 1] = sorted_values[j];
	    sorted_inds[j + 1] = sorted_inds[j];
	    j = j -1;
	}
	sorted_values[j+1] = key;
	sorted_inds[j+1] = i;
    }

    // compute quantile ...
    std::vector <double> sorted_norm_values;
    double sum = 0.0;
    for (i = 0; i < n; i++)
	sum = sum + sorted_values[i];
    for (i = 0; i < n; i++)
	sorted_norm_values.push_back(sorted_values[i] / sum);

    if (n > 20)
    {

	double qs = quantile(sorted_norm_values, q);

	for (i = 0; i < n ; i++)
	{
	    if (sorted_norm_values[i] < qs)
		break;
	    result = result + std::to_string(sorted_inds[i]) + ":" + std::to_string(sorted_values[i]) + ":" + std::to_string(sorted_norm_values[i]) + "\t";
	}
	result = result +"\n";
    } // if more than 20 topics
    else
    {
	for (i = 0; i < n ; i++)
	{
	    result = result + std::to_string(sorted_inds[i]) + ":" + std::to_string(sorted_values[i]) + ":" + std::to_string(sorted_norm_values[i]) + "\t";
	}
	result = result +"\n";
    }// less than 20 topics, just print all

    return result;
}

double quantile (std::vector<double> values, double q)
{
    /* r - 7 The 7th method from R quantile function
       probs = c(0.25) #q
       n = length(x)
       index = 1 + (n - 1) * probs
       lo = floor(index)
       hi = ceiling(index)
       sx = sort(x, partial=unique(c(lo,hi))) # only need hi and lo to be correctly sorted
       qs = x[lo]
       i = which(index > lo & x[hi] !=qs)
       h = (index - lo)[i]
       qs[i] = (1 - h) * qs[i] + h * x[hi[i]]
       */

    q = 1 - q;
    int n = values.size();
    double index = (n - 1) * q; // remove the 1 from R!
    int lo = std::floor(index);
    int hi = std::ceil(index);
    double h = index - lo;
    double qs = values[lo];
    qs = (1 - h) * qs  + h * values[hi];
    return qs;
}//quantile

std::vector<std::string> strsplit (std::string input, char delim) 
{
    std::vector<std::string> result;
    std::stringstream ss;
    ss.str(input);
    std::string item;

    while (getline (ss, item, delim)) {
	result.push_back (item);
    }

    return result;
} // strsplit
